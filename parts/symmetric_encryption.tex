\section{Gizli Anahtarlı Şifreleme (Symmetric Encryption)}

Simetrik şifrelemede, aynı anahtar hem şifreleme hem de şifre çözme işlemleri için kullanılır. Veri, bir şifreleme algoritması ve bir gizli anahtar kullanılarak şifrelenir. Şifrelenmiş veri, aynı gizli anahtarı bilen bir alıcıya gönderilir. Alıcı, aynı anahtarı kullanarak veriyi çözer ve orijinal haline ulaşır. Çok hızlıdır. Anahtar paylaşımı güvenli bir şekilde yapılmazsa sistem kırılabilir Her iki taraf da aynı gizli anahtara sahip olmalıdır. VPN bağlantılarında kullanılır. 

\begin{itemize}
    \item \textbf{Blok Şifreleme}: Veriyi sabit uzunlukta bloklara bölerek şifreler. Örneğin; DES, 3DES, AES.
    \item \textbf{Akış Şifreleme}: Veriyi tek tek bitler veya baytlar halinde şifreler. Örneğin; RC4, Salsa20, ChaCha20.
    \item \textbf{Hybrid Yaklaşımlar}: Akış ve blok şifrelemenin avantajlarını birleştirir. Çoğu modern protokolde hibrit modeller tercih edilir.
\end{itemize}

\subsection{DES (Data Encryption Standard)}

DES, 1970'lerde IBM tarafından geliştirilmiş ve ABD hükümeti tarafından standart olarak kabul edilmiş bir blok şifreleme algoritmasıdır. Veriyi 64 bitlik bloklar halinde işler ve 56 bit bir anahtar kullanır. Her bloğun son bit parity için kullanıldığından şifreleme işleminde kullanılmaz, bu yüzden 56 bit anahtar kullanır. 56-bit anahtar uzunluğu kısa olduğundan brute-force saldırılarına karşı zayıftır. Şifreleme ve şifre çözme için Feistel yapısını kullanır ve şifreleme işlemi toplamda 16 tur gerçekleştirir. Her turda farklı bir alt anahtar kullanarak veriyi işler. 

Açık anahtarlı şifrelemenin kurucularından Whitfield Diffie ve Martin Hellman, DES'in ticari amaçlar için güvenli olduğunu fakat istihbat için kullanılmaması gerektiğini, algoritmanın saldırılara karşı dayanıksız olduğunu ifade ettiler. Anahtar boyutunun kısa olması ve algoritma içerisindeki S kutularının güvenirliliğinin az olmasından söz ettiler. Buna rağmen DES algoritması kullanılmaya devam edildi. 1977 yılında Whitfield Diffie ve Martin Hellman, maliyeti 20 milyon dolar olan "DES-Crack" isimli DES algoritmasının anahtarını 1 günde bulabilecek bir makine önerdiler. 1993 yılında Michael Wiener, maliyeti 1 milyon dolar olan ve DES algoritmasının anahtarını 7 saatte bulabilecek bir makine önerdi. Her iki çalışma da yüksek maliyetten dolayı gerçekleşmedi. 1990 yılında Eli Bilham ve Adi Shamir diferensiyel kriptanaliz metodu ile DES üzerinde bir saldırı gerçekleştirdiler fakat bu girişim başarısız oldu. 1993 yılında Mitsuru Matsui DES algoritması üzerinde lineer kriptanaliz yöntemi tasarladı. Bu, DES üzerinde uygulanan ilk deneysel kriptanaliz yöntemi oldu. Daha sonra ise, DES algoritması için özel olarak Davies saldırısı yöntemi tasarlandı. Donald Davies tarafından önerilen bu saldırı, Eli Bilham ve Biryukov tarafından geliştirildi. Saldırı, $2^{50}$ hesaplama maliyetine sahipti. 1998 yılında EFF, 250 bin dolar maliyetle "Deep Crack" isminde, DES algoritmasının tüm anahtar ihtimallerini deneyen bir makine üretti. Saniyede 90 milyar anahtarı test edebilen ve her biri 64 mikroçip içeren 27 karttan oluşan bu makine, 56 bitlik bir anahtar ile şifrelenmiş bir metni 56 saatte kırdı. Bu olay, DES algoritmasına olan güvenin sarsılmasına yol açtı. Bu olaydan sonra 1999 yılında Triple DES (3DES) yöntemi geliştirildi.

\subsubsection{Encryption}

\begin{enumerate}
    \item Veri, sabit bir permütasyon tablosu (initial permutation) kullanılarak yeniden düzenlenir.
    \item Veri, Feistel yapısı ile 16 tur işlenir. Her turda, veri $L_i$ (sol) ve $R_i$ (sağ) olmak üzere 32-bitlik iki yarıya bölünür. Sağ taraf, bir fonksiyon ve bir alt anahtarla işlenir, ardından sol tarafla XOR yapılır. Sol ve sağ taraf yer değiştirir.
    \item İşlenen veri (final permutation), başlangıç permütasyonunun tersine göre düzenlenir.
    \item Şifreleme işlemi tamamlanır.
\end{enumerate}

\subsubsection{Python Kodu}

\begin{lstlisting}[language=Python]
from Crypto.Cipher import DES
from Crypto.Util.Padding import pad, unpad

def des_encrypt(plaintext, key):
    if len(key) != 8:
        raise ValueError("")

    cipher = DES.new(key, DES.MODE_ECB)
    padded_text = pad(plaintext.encode(), 8)
    encrypted = cipher.encrypt(padded_text)
    return encrypted

def des_decrypt(ciphertext, key):
    if len(key) != 8:
        raise ValueError("")

    cipher = DES.new(key, DES.MODE_ECB)
    decrypted_padded_text = cipher.decrypt(ciphertext)
    decrypted = unpad(decrypted_padded_text, 8)
    return decrypted.decode()

plaintext = "Hello, World!"
key = b"secretky"
encrypted = des_encrypt(plaintext, key)
decrypted = des_decrypt(encrypted, key)
print("Encrypted:", encrypted)
print("Decrypted:", decrypted)
\end{lstlisting}

\newpage

\subsection{3DES (Triple Data Encryption Standard)}

3DES, DES algoritmasının güvenlik açıklarını kapatmak için geliştirilmiş bir genişletilmiş versiyonudur. 3 farklı anahtar veya aynı anahtarın farklı kombinasyonlarını kullanarak 3 adımda şifreleme ve şifre çözme işlemleri gerçekleştirir. Bir veri bloğu üzerinde DES algoritması şu sırayla üç kez uygulanır:

\begin{enumerate}
    \item İlk anahtar ile DES şifrelemesi uygulanır.
    \item İkinci anahtar ile DES şifre çözmesi uygulanır.
    \item Üçüncü anahtar ile tekrar DES şifrelemesi uygulanır.
\end{enumerate}

\[ C = E_{K_3}(D_{K_2}(E_{K_1}(P)))\]

Burada, $P$, düz metin (plaintext); $C$, şifrelenmiş metin (ciphertext); $E$, DES şifreleme işlemi; $D$, DES şifre çözme işlemidir.

\subsubsection{Python Kodu}

\begin{lstlisting}[language=Python]
from Crypto.Cipher import DES3
from Crypto.Util.Padding import pad, unpad
from Crypto.Random import get_random_bytes

def triple_des_encrypt(plaintext, key):
    cipher = DES3.new(key, DES3.MODE_ECB)
    padded_text = pad(plaintext.encode(), 8)
    encrypted = cipher.encrypt(padded_text)
    return encrypted

def triple_des_decrypt(encrypted, key):
    cipher = DES3.new(key, DES3.MODE_ECB)
    decrypted_padded_text = cipher.decrypt(encrypted)
    decrypted = unpad(decrypted_padded_text, 8)
    return decrypted.decode()

key = get_random_bytes(24)
plaintext = "Hello, World!"
DES3.adjust_key_parity(key)
encrypted = triple_des_encrypt(plaintext, key)
decrypted = triple_des_decrypt(encrypted, key)
print("Encrypted:", encrypted)
print("Decrypted:", decrypted)
\end{lstlisting}

\newpage

\subsection{AES (Advanced Encryption Standard)}

AES (Advanced Encryption Standard), 2001 yılında Rijndael algoritması temel alınarak geliştirilmiş modern ve güvenli bir blok şifreleme algoritmasıdır. Veri güvenliği için dünya çapında yaygın olarak kullanılan bir standarttır. AES, sabit bir 128 bit blok boyutunda çalışır. Farklı güvenlik seviyeleri için 3 farklı anahtar uzunluğunu destekler: 128 bit (10 tur), 192 bit (12 tur) ve 256 bit (14 tur). AES, hem donanım hem de yazılım ortamlarında hızlıdır ve brute-force saldırılarına karşı oldukça dayanıklıdır.

\subsubsection{Encryption}

\begin{enumerate}
    \item Düz metin, ilk olarak anahtar ile XOR işlemine girer.
    \item Her tür şu 4 adımdan oluşur:
    \begin{itemize}
        \item \textbf{SubBytes (Bayt Değiştirme)}: Her bayt, S-box adı verilen bir tablo yardımıyla bir başkasıyla değiştirilir. Doğrusal olmayan bir işlemdir. Durum matrisi üzerinde uygulanır. 128 bitlik bir anahtar için durum matrixi her elemanı 8 bit olan 4x4'lük bir matristir. Bu matrisin her bir elemanı 16'lık sayı tabanında yazılır. Durum matrisindeki her eleman, elemanın satır-sütun koordinatı ile S kutusu üzerindeki o koordinatta bulunan değerle değiştirilir.
        \item \textbf{ShiftRows (Satır Kaydırma)}: Veri bloğundaki satırlar belirli bir düzene göre kaydırılır. Güncellenmiş durum matrisi üzerinde uygulanır. Her satır belirli bir oranda kaydırılır. Her n. satırda $n - 1$'lik bir kaydırma yapılır, yani ilk satırda herhangi bir kaydırma olmazken, diğer satırlarda kendisinin bir eksiği kadar kaydırma yapılır.
        \item \textbf{MixColumns (Sütun Karıştırma)}: Sütunlar matematiksel bir işlemle karıştırılır. Kaydırılan durum matrisi, sabit bir matris ile çarpılır.
        \item \textbf{AddRoundKey (Tur Anahtarı Ekleme)}: Veri bloğu, o tura ait alt anahtar ile XOR yapılır. Toplama işlemi sütun bazlı yapılır.
    \end{itemize}
    \item Son turda, SubBytes, ShiftRows ve AddRoundKey işlemleri yapılır. MixColumns atlanır.
    \item Tüm turlar tamamlandıktan sonra şifreli metin elde edilir.
\end{enumerate}

\subsubsection{Python Kodu}

\begin{lstlisting}[language=Python]
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from Crypto.Random import get_random_bytes

def aes_encrypt(plaintext, key):
    cipher = AES.new(key, AES.MODE_CBC)
    iv = cipher.iv
    padded_text = pad(plaintext.encode(), AES.block_size)
    encrypted = cipher.encrypt(padded_text)
    return iv + encrypted

def aes_decrypt(encrypted, key):
    iv = encrypted[:AES.block_size]
    actual_encrypted_text = encrypted[AES.block_size:]
    cipher = AES.new(key, AES.MODE_CBC, iv)
    decrypted_padded_text = cipher.decrypt(actual_encrypted_text)
    decrypted = unpad(decrypted_padded_text, AES.block_size)
    return decrypted.decode()

key = get_random_bytes(24)
plaintext = "Hello, World!"
encrypted = triple_des_encrypt(plaintext, key)
decrypted = triple_des_decrypt(encrypted, key)
print("Encrypted:", encrypted)
print("Decrypted:", decrypted)
\end{lstlisting}

\newpage

\subsection{Salsa20}

2005 yılında Daniel J. Bernstein tarafından tasarlananmış bir akış şifreleme algoritmasıdır. Yüksek hızda ve düşük donanım gereksinimleriyle çalışması için geliştirilmiştir. Salsa20, sabit zamanlı algoritma olarak tasarlanmıştır, bu da yan kanal saldırılarına karşı dayanıklılık sağlar. Anahtar uzunluğu 256 bittir. Temel olarak, XOR, ekleme, döndürme ve karıştırma işlemlerine dayanır. Bir anahtar ve 64 bitlik nonce (keyfi sayı) kullanarak bir keystream oluşturur ve bu keystream ile veriyi XOR işlemini sokarak şifreler. Nonce, aynı anahtarla şifreleme yapılırken keystream'lerin farklı olmasını sağlar. Blok sayacı, bloklar arasında tekrar eden keystream olmasını önler.

\subsubsection{Encryption}

\begin{enumerate}
    \item 512 bitlik bir başlangıç durumu oluşturulur. Bu durum; sabit dizi, anahtar, nonce ve blok sayacından oluşur.
    \item 20 tur boyunca durum üzerinde XOR, quarterround (çeyrek tur), rowround (satır turu) ve columnround (sütun turu) işlemleri yapılır.
    \item Bu turlar sonucunda oluşan veri keystream olarak adlandırılır.
    \item Düz metin bu keystream ile XOR işlemine sokularak şifrelenir. Aynı keystream ile şifrelenmiş metin tekrar XOR işlemine sokularak düz metin elde edilir.
\end{enumerate}

\subsubsection{Python Kodu}

\begin{lstlisting}[language=Python]
from Crypto.Cipher import Salsa20

def salsa20_encrypt(plaintext, key):
    cipher = Salsa20.new(key=key)
    encrypted = cipher.encrypt(plaintext.encode())
    ciphertext = cipher.nonce + encrypted
    return ciphertext

def salsa20_decrypt(ciphertext, key):
    nonce = ciphertext[:8]
    cipher = Salsa20.new(key=key, nonce=nonce)
    plaintext = cipher.decrypt(ciphertext[8:]).decode()
    return plaintext

key = b"secretsecretkey!"
plaintext = "Hello, World!"
ciphertext = salsa20_encrypt(plaintext, key)
decrypted = salsa20_decrypt(ciphertext, key)
print("Encrypted:", ciphertext)
print("Decrypted:", decrypted)
\end{lstlisting}

\newpage

\subsection{Kuantum Kriptografi}

Kuantum kriptografi, kuantum mekaniğinin temel ilkelerine dayanan bir şifreleme yöntemidir. Diğer yöntemlerden farklı olarak, veri güvenliğini matematiksel hesaplamaların karmaşıklığından ziyade fiziksel prensiplere dayandırır. Bilgiler, kuantum bitleri (qubit) ile temsil edilir. Qubit'ler 0, 1 veya bu ikisinin süperpozisyonu şeklinde olabilir. Kuantum Kriptografi, Heisenberg Belirsizlik İlkesini kullanır. Kuantum parçacığının özelliklerini ölçmek, o parçacığın durumunu değiştirir. Bu özellik, dinleme girişimlerini tespit etmeyi sağlar. Kuantum durumları, birbiriyle çakışmayan bazlarda ölçüldüğünde kesin bilgi vermez. Bu, iletişim güvenliğini artırır. Dolaşıklık (Entanglement), iki veya daha fazla parçacığın durumlarının birbirine bağlı olması durumudur. Bu bağlantı, fiziksel olarak ayrı yerlerde bile ölçümler arasında güçlü bir bağıntı sağlar.

\subsubsection{BB84 Algorithm}

BB84 Algoritması, 1984 yılında Charless Bennett ve Gilles Brassard tarafından geliştirilen ilk kuantum anahtar dağıtım protokolüdür. 

\begin{enumerate}
    \item Alice, rastgele bir bit dizisi ve baz dizisi seçer. Bitleri seçilen bazlara göre kuantum durumlarına dönüştürür ve Bob'a gönderir.
    \item Bob, rastgele bazlar seçerek kuantum bitlerini ölçer. Bazlar doğru seçildiyse, Alice'in gönderdiği biti doğru şekilde ölçer; aksi takdirde rastgele bir sonuç elde eder.
    \item Alice ve Bob, bir kanal üzerinden hangi bazları kullandıklarını paylaşır, bitlerin kendisini paylaşmazlar. Sadece aynı bazda ölçülen bitler korunur ve diğerleri atılır.
    \item Kalan bitler, ortak bir gizli anahtar olarak kullanılır.
    \item Alice ve Bob, anahtarın bir kısmını karşılaştırarak Eve'in dinleme girişimlerini tespit eder. Eğer müdahale varsa, kuantum durumlarındaki değişimden dolayı hata oranı artar.
\end{enumerate}

\subsubsection{EPR-Ekert Protocol}

EPR-Ekert Protokolü, 1991 yılında Artur Ekert tarafından önerilen bir kuantum anahtar dağıtım protokolüdür. Bu protokol, Einstein-Podolsky-Rosen (EPR) dolaşıklığı üzerine kuruludur. 

\begin{enumerate}
    \item Alice ve Bob, dolaşık kuantum parçacıkları alır. Bu parçacıklar, birbirinden bağımsız iki uzak yerde ölçülür.
    \item Alice ve Bob, ölçümlerini farklı yönlerde rastgele yapar. Ölçüm sonuçları, kuantum mekaniğinin yasaları nedeniyle güçlü bir şekilde korelasyonludur.
    \item Eğer Eve, kuantum kanalı dinlemeye çalışırsa, dolaşıklık bozulur ve korelasyonlar değişir. Bu, dinleme girişimlerini tespit etmeyi sağlar.
    \item Alice ve Bob, ölçüm sonuçlarının korelasyonuna dayanarak bir gizli anahtar oluşturur.
\end{enumerate}

\newpage

\subsection{Post-Kuantum Kriptografi (PQC)}

Post-Kuantum Kriptografi, kuantum bilgisayarların geleneksel kriptografi yöntemlerini tehdit etmesinden dolayı ortaya çıkmıştır. Geleneksel şifreleme yöntemleri büyük ölçüde matematiksel problemlerin çözüm zorluğuna dayanır. Ancak kuantum bilgisayarlar, güçlü algoritmalar sayesinde bu matematiksel problemleri etkili bir şekilde çözebilir. Post-Kuantum Kriptografi, kuantum bilgisayarların bu potansiyel tehditlerine karşı dayanıklı algoritmalar sunmayı amaçlar. Bu algoritmalar, kuan tum bilgisayarların güçlü işlem kapasitesine dayanacak şekilde tasarlanmıştır. Sadece kuantum saldırıları değil, aynı zamanda klasik bilgisayarların saldırılarına karşı da dayanıklıdır. Henüz tam olarak benimsenmiş standartlar yoktur ve standartlaştırma süreci devam etmektedir. PQC, problem kategorileri;

\begin{itemize}
    \item \textbf{Izgara (Lattice)}: Çok boyutlu geometrik ızgaralarda kısa vektörlerin bulunması zorluğuna dayanır. Kullanılan algoritmalar: Learning with Errors (LWE), NTRU.
    \item \textbf{Kodlama (Code)}: Hata düzeltme kodlarının çözümündeki zorluğa dayanır. Kullanılan algoritmalar: McEliece.
    \item \textbf{Çok Değişkenli Polinomlar (Multivariate Polynomials)}: Çok değişkenli polinomların sıfırlarının bulunmasındaki zorluğa dayanır. Kullanılan algoritmalar: Rainbow, UOV (Unbalanced Oil and Vinegar).
    \item \textbf{Hash}: Güvenli hash fonksiyonlarına dayanır. Kullanılan algoritmalar: SPHINCS+.
    \item \textbf{Diğer}: Farklı matematiksel zorluklardan yararlanır. Kullanılan algoritmalar: Supersingular Elliptic Curve Isogeny (SIEC).
\end{itemize}



\newpage